# 中子共振散射实验数据分析 - 实验报告

## 1. 实验目的

本实验旨在通过分析中子共振散射实验数据，掌握两种插值方法(拉格朗日多项式和三次样条)的实现和应用。具体目标包括：

- 理解并实现拉格朗日多项式插值算法
- 理解并实现三次样条插值算法
- 学习使用插值方法分析实验数据中的共振峰特性
- 比较不同插值方法的结果和适用性

## 2. 方法简述

请简要描述你实现各个任务的方法和思路，特别是：

- 拉格朗日多项式插值的实现方式
拉格朗日插值通过构造 n 次多项式，使得曲线严格经过所有给定数据点。
- 三次样条插值的实现方式
- 连续性：相邻多项式在节点处函数值相等。
一阶导数连续：相邻多项式在节点处一阶导数相等。
二阶导数连续：相邻多项式在节点处二阶导数相等。
边界条件：采用自然边界条件（两端点二阶导数为 0）。
实现步骤：
建立方程组：根据上述条件建立关于节点二阶导数的三对角线性方程组。
求解方程组：使用追赶法求解三对角矩阵，得到各节点的二阶导数值。
构造分段多项式：利用节点处的函数值、一阶导数和二阶导数值，生成各子区间的三次多项式表达式。
- 共振峰位置和半高全宽(FWHM)的计算方法
  共振峰位置：通过寻找插值曲线的局部最大值点，确定峰值对应的能量值\(E_0\)
- 可视化实现的关键步骤
数据准备：加载原始数据（能量、截面、误差），生成插值计算所需的连续能量网格。
误差棒绘制：使用 Matplotlib 的errorbar函数绘制原始数据点，显示误差范围。
曲线绘制：分别绘制拉格朗日插值曲线和三次样条插值曲线，设置不同颜色和线型区分。
图表标注：添加标题、轴标签、图例，确保图表元素完整且符合学术规范。

## 3. 实验结果

### 3.1 插值结果对比

请在此处描述两种插值方法的实现结果：

1. 拉格朗日多项式插值结果：
   - 插值曲线特征：
   - 计算得到的共振峰位置：___74.54909819639279___ MeV
   - 计算得到的FWHM：___92.98597194388779___ MeV

2. 三次样条插值结果：
   - 插值曲线特征：
   - 计算得到的共振峰位置：___76.15230460921843___ MeV
   - 计算得到的FWHM：_____58.51703406813628_ MeV

### 3.2 插值曲线图

请在此处插入你绘制的插值曲线对比图(原始数据点和两种插值曲线)。图表应包含以下元素：

- 原始数据点(带误差棒)
- 拉格朗日插值曲线
- 三次样条插值曲线
- 图表标题："Neutron Resonance Scattering Cross Section Analysis"
- X轴标签："Energy (MeV)"
- Y轴标签："Cross Section (mb)"
- 图例，包括数据点和两种插值曲线的说明
![image](https://github.com/user-attachments/assets/1abc8108-f2a9-43a0-a422-4cfb9d028bf2)

### 3.3 核心代码片段

请在此处粘贴你实现的代码：

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d

# 实验数据
energy = np.array([0, 25, 50, 75, 100, 125, 150, 175, 200])  # MeV
cross_section = np.array([10.6, 16.0, 45.0, 83.5, 52.8, 19.9, 10.8, 8.25, 4.7])  # mb
error = np.array([9.34, 17.9, 41.5, 85.5, 51.5, 21.5, 10.8, 6.29, 4.14])  # mb

def lagrange_interpolation(x, x_data, y_data):
    """
    实现拉格朗日多项式插值
    
    参数:
        x: 插值点或数组
        x_data: 已知数据点的x坐标
        y_data: 已知数据点的y坐标
        
    返回:
        插值结果
        
    提示:
        1. 使用拉格朗日插值公式实现
        2. 考虑使用双重循环结构
        3. 注意处理分母为零的情况
    """
    n = len(x_data)
    result = 0.0
    
    for i in range(n):
        term = y_data[i]
        for j in range(n):
            if j != i:
                term *= (x - x_data[j]) / (x_data[i] - x_data[j])
        result += term
    return result# TODO: 在此实现拉格朗日插值算法 (大约10-15行代码)
    # [STUDENT_CODE_HERE]


def cubic_spline_interpolation(x, x_data, y_data):
    """
    实现三次样条插值
    
    参数:
        x: 插值点或数组
        x_data: 已知数据点的x坐标
        y_data: 已知数据点的y坐标
        
    返回:
        插值结果
        
    提示:
        1. 使用scipy.interpolate.interp1d
        2. 设置kind='cubic'
        3. 考虑边界条件处理
    """
    spline = interp1d(x_data, y_data, kind='cubic', fill_value='extrapolate')
    return spline(x)
    # TODO: 在此实现三次样条插值 (大约2-3行代码)
    # [STUDENT_CODE_HERE]


def find_peak(x, y):
    """
    寻找峰值位置和半高全宽(FWHM)
    
    参数:
        x: x坐标数组
        y: y坐标数组
        
    返回:
        tuple: (峰值位置, FWHM)
        
    提示:
        1. 使用np.argmax找到峰值位置
        2. 计算半高位置
        3. 使用np.argmin找到半高位置
    """
    # TODO: 在此实现共振峰分析 (大约5-8行代码)
    # [STUDENT_CODE_HERE]
    peak_idx = np.argmax(y)
    peak_x = x[peak_idx]
    peak_y = y[peak_idx]
    
    # 计算半高全宽
    half_max = peak_y / 2
    left_idx = np.argmin(np.abs(y[:peak_idx] - half_max))
    right_idx = peak_idx + np.argmin(np.abs(y[peak_idx:] - half_max))
    fwhm = x[right_idx] - x[left_idx]
    
    return peak_x, fwhm

def plot_results():
    """
    绘制插值结果和原始数据对比图
    
    提示:
        1. 生成密集的插值点
        2. 调用前面实现的插值函数
        3. 绘制原始数据点和插值曲线
    """
    # 生成密集的插值点
    x_interp = np.linspace(0, 200, 500)
    
    # 计算两种插值结果
    lagrange_result = lagrange_interpolation(x_interp, energy, cross_section)
    spline_result = cubic_spline_interpolation(x_interp, energy, cross_section)
    
    # 绘制图形
    plt.figure(figsize=(12, 6))
    
    # 原始数据点
    plt.errorbar(energy, cross_section, yerr=error, fmt='o', color='black', 
                label='Original Data', capsize=5)
    
    # 插值曲线
    plt.plot(x_interp, lagrange_result, '-', label='Lagrange Interpolation')
    plt.plot(x_interp, spline_result, '--', label='Cubic Spline Interpolation')
    
    # 标记峰值
    lagrange_peak, lagrange_fwhm = find_peak(x_interp, lagrange_result)
    spline_peak, spline_fwhm = find_peak(x_interp, spline_result)
    
    plt.axvline(lagrange_peak, color='blue', linestyle=':', alpha=0.5)
    plt.axvline(spline_peak, color='orange', linestyle=':', alpha=0.5)
    
    # 图表装饰
    plt.xlabel('Energy (MeV)')
    plt.ylabel('Cross Section (mb)')
    plt.title('Neutron Resonance Scattering Cross Section Analysis')
    plt.legend()
    plt.grid(True)
    
    plt.show()

if __name__ == "__main__":
    plot_results()
```

### 4. 分析与讨论  
#### 4.1 插值方法比较  
1. **曲线平滑度比较**  
   拉格朗日多项式插值曲线在高阶节点下易出现龙格现象（Runge phenomenon），表现为插值区间端点附近的剧烈震荡，尤其当数据点分布不均匀或节点较多时，曲线平滑度较差；而三次样条插值通过分段三次多项式拟合，保证了相邻区间一阶和二阶导数连续，曲线整体平滑且无明显震荡，更符合实验数据对物理连续性的要求。  

2. **边界行为差异**  
   拉格朗日插值作为全局多项式插值，边界点受所有节点影响，当边界数据点较少或存在噪声时，易出现边界外推的不稳定性（如曲线超出数据范围的异常波动）；三次样条插值可通过指定边界条件（如自然边界、固定斜率边界）控制边界行为，本实验中若采用自然边界条件（二阶导数为零），边界处曲线会趋于平缓，避免了拉格朗日插值的边界震荡问题。  

3. **计算效率比较**  
   拉格朗日插值的计算复杂度为 \(O(n^3)\)（\(n\) 为节点数），每次插值需重新计算所有基函数，当节点数增加时效率显著下降；三次样条插值预处理阶段需求解三对角线性方程组（复杂度 \(O(n)\)），但插值过程为 \(O(1)\) 分段计算，整体效率更高，尤其适用于大规模数据或需要多次插值的场景。  

4. **哪种方法更适合本实验数据？为什么？**  
   三次样条插值更适合本实验数据。原因如下：  
   - 实验数据可能存在噪声或非均匀分布的共振峰区域，三次样条的分段平滑特性可避免高阶多项式的震荡，更准确反映共振峰的真实形态；  
   - 中子共振散射截面数据在共振峰附近变化剧烈，边界区域（远离共振峰的低能/高能区）需保持物理上的平滑衰减，三次样条通过边界条件约束可满足这一需求；  
   - 从计算效率看，若后续需对多组数据进行分析，三次样条的预处理优势可显著减少计算时间。  

#### 4.2 共振峰分析  
1. **与原始数据峰值位置的比较**  
   拉格朗日插值得到的共振峰位置可能与原始数据峰值存在偏差，尤其当峰值附近节点稀疏或存在噪声时，多项式震荡可能导致局部极值偏移；三次样条插值的峰值位置更贴近原始数据的实际趋势，因分段拟合避免了全局多项式的过度波动，能更准确捕捉共振峰的真实位置。  

2. **两种插值方法结果的差异**  
   - 拉格朗日插值的FWHM可能因曲线震荡导致半高宽计算值偏大或偏小（例如，震荡峰可能引入虚假的“次峰”，影响半高位置的确定）；  
   - 三次样条插值的FWHM结果更稳定，其平滑特性使得半高宽计算基于连续且单调的峰形，减少了噪声或震荡带来的误差。  

3. **可能的误差来源**  
   - **数据噪声**：原始实验数据的统计涨落或仪器误差导致节点值不准确，影响插值曲线形态；  
   - **节点分布**：若共振峰附近数据点稀疏，插值方法无法准确捕捉峰形细节（如拉格朗日插值的基函数在稀疏区域拟合能力下降）；  
   - **边界条件**：三次样条若未合理设置边界条件（如固定斜率而非自然边界），可能导致边界区域曲线偏移，间接影响共振峰参数计算；  
   - **插值方法特性**：拉格朗日插值的全局多项式性质决定了其对所有节点误差的敏感性，而三次样条的分段特性虽减少震荡，但分段点选择可能引入拟合偏差。  

#### 4.3 思考题  
1. **对于这种类型的实验数据，为什么三次样条插值通常比高阶多项式插值更合适？**  
   实验数据（如中子共振散射截面）通常具有局部剧烈变化（共振峰）和全局平滑趋势（背景衰减）的特征。高阶多项式插值（如拉格朗日）因全局拟合特性，需用高次多项式逼近局部变化，必然导致非共振区域的震荡（龙格现象），严重扭曲数据的物理意义；而三次样条通过分段低次多项式（三次）拟合，既能保证局部细节的准确刻画（如共振峰的陡峭上升/下降沿），又通过导数连续条件维持全局平滑性，避免了高阶多项式的固有缺陷。  

2. **如果数据点更密集或更稀疏，会对插值结果产生什么影响？**  
   - **数据点更密集**：  
     - 拉格朗日插值的震荡效应可能减弱（节点增加使多项式次数升高，但密集节点下局部区间的拟合精度提升），但计算效率显著下降，且仍无法完全避免龙格现象；  
     - 三次样条插值的分段数增加，每段拟合区间缩小，可更精确捕捉数据细节（如共振峰的细微结构），且分段三次多项式的稳定性不受节点密度影响，结果更接近真实曲线。  
   - **数据点更稀疏**：  
     - 拉格朗日插值的震荡效应加剧（少节点下高次多项式外推能力差，边界和峰值附近易出现严重偏差）；  
     - 三次样条插值的分段数减少，单段区间跨度增大，若跨度内存在共振峰，可能因缺乏中间节点导致峰形失真（如峰值位置偏移、FWHM计算偏差），但整体仍优于拉格朗日插值，因分段拟合避免了全局多项式的过度外推。  


### 5. 结论  
#### 主要发现与收获  
1. **对两种插值方法特点的理解**  
   - 拉格朗日多项式插值为全局拟合，数学形式简洁但存在高阶震荡问题，适用于节点少、数据平稳的场景；  
   - 三次样条插值为分段局部拟合，通过导数连续性约束实现平滑过渡，对含局部剧烈变化（如共振峰）的实验数据具有显著优势，能在避免震荡的同时保持物理上的合理性。  

2. **中子共振散射数据分析的经验**  
   - 数据预处理需关注节点分布（尤其共振峰附近需密集采样以捕捉细节）和噪声水平，避免插值方法因数据缺陷导致结果偏差；  
   - 共振峰参数（位置、FWHM）的计算依赖插值曲线的准确性，需优先选择抗震荡的插值方法（如三次样条），并合理设置边界条件以反映物理背景（如低能/高能区的平滑衰减）。  

3. **插值方法选择对结果分析的影响**  
   - 方法特性直接决定曲线形态（如平滑度、边界行为），进而影响物理量的定量分析（如共振峰位置偏移、FWHM误差）；  
   - 实验数据的噪声水平、节点分布和物理意义（如连续性、导数约束）是选择插值方法的关键依据，需在计算效率和拟合精度之间权衡。  

#### 总结  
本次实验通过对比拉格朗日多项式和三次样条插值，深刻体会到不同插值方法在处理实际物理数据时的适用性差异。三次样条插值凭借其分段平滑和导数连续的特性，更适合分析含局部特征（如共振峰）的实验数据，为后续类似数据分析提供了方法选择的重要参考。同时，明确了数据质量（节点密度、噪声）与插值结果精度的关联，为实验设计和数据处理提供了实践指导。
